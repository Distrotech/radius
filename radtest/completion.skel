/* -*- c -*- 
   This file is part of GNU Radius.
   Copyright (C) 2004 Free Software Foundation, Inc.

   Written by Sergey Poznyakoff
 
   GNU Radius is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
 
   GNU Radius is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with GNU Radius; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if defined(HAVE_CONFIG_H)        
# include <config.h>
#endif
#include <stdio.h>
#ifdef HAVE_READLINE_READLINE_H
# include <readline/readline.h>
#endif
#include <common.h>
#include <radius/radius.h>	
#include <radtest.h>
#include "gram.h"

struct key_tab {
	char *name;
	int len;
	int tok;
	int initial;
	int *successors;
};

@@DATA@@

static struct key_tab *
find_keyword(char *text, int start, int len)
{
        struct key_tab *kp;
	
	for (kp = key_tab; kp->name; kp++) {
                if (len >= kp->len &&
		    strncasecmp(kp->name, text+start, len) == 0) 
                        return kp;
        }
	return NULL;
}

static struct key_tab *
find_prev_word(int start)
{
	int len;

	if (start == 0)
		return 0;
	start--;
	while (start > 0 && isspace(rl_line_buffer[start]))
		start--;
	if (start == 0)
		return 0;
	/* find start of the word */
	len = 0;
	while (start > 0 && !isspace(rl_line_buffer[start])) {
		start--;
		len++;
	}
	
	return find_keyword(rl_line_buffer, start, len);
}

static char *
token_name(int n)
{
	struct key_tab *kp;

	for (kp = key_tab; kp->name; kp++)
		if (kp->tok == n)
			return kp->name;
	return NULL;
}

static char *
gen_state0_list(const char *text, int state)
{
	static int len;
	static struct key_tab *kp;
	char *str;
	
	if (!state) {
		len = strlen(text);
		kp = key_tab;
	}

	while (str = (kp++)->name) 
		if (len == 0
		    || (len <= strlen(str) && strncasecmp(str, text, len) == 0))
			
			return strdup(str);
	return NULL;
}

static int *successor_ind;

static char *
gen_successor_list(const char *text, int state)
{
	static int len;
	int n;
	
	if (!state) 
		len = strlen(text);

	while (n = *successor_ind++) {
		char *str = token_name(n);
		if (len == 0 ||
		    (len <= strlen(str) &&
		     strncasecmp(str, text, len) == 0)) 
			return strdup(str);
	}
	return NULL;
}

char **
radtest_command_completion(char *text, int start, int end)
{
	struct key_tab *prev;
	if (start == 0) 
		return rl_completion_matches(text, gen_state0_list);
	else if (prev = find_prev_word(start)) {
		successor_ind = prev->successors;
		return rl_completion_matches(text, gen_successor_list);
	}
}

/* End of completion.skel */
