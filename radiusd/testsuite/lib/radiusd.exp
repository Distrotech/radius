# -*- tcl -*-
# This file is part of GNU RADIUS testsuite.
# Copyright (C) 2000,2001, Sergey Poznyakoff
#  
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#   
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#  
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 

if [info exists TOOL_EXECUTABLE] {
    set RADIUSD $TOOL_EXECUTABLE
}
if ![info exists RADIUSD] {
    if ![is_remote host] {
	set RADIUSD [findfile $base_dir/../radiusd "$base_dir/../radiusd" [transform radiusd]]
    } else {
	if [info exists host_board] {
	    if [board_info $host_board exists top_builddir] {
		append RADIUSD "[board_info $host_board top_builddir]/radiusd/radiusd"
	    } elseif [board_info $host_board exists top_srcdir] {
		append RADIUSD "[board_info $host_board top_srcdir]/radiusd/radiusd"
	    }
	}

	if ![info exists RADIUSD] {
	    perror "The test suite is not set up for the remote testing"
	    perror "Please, read file README in test/dejagnu subdirectory"
	    perror "for instructions on how to set up it."
	    exit 1
	}
    }
}

verbose "using RADIUSD = $RADIUSD" 2

set num [regsub "(.*)/radiusd" $RADIUSD "\\1/../radtest/radtest" RADTEST]

verbose "using RADTEST = $RADTEST" 2

# The variable runtest_prompt is a regexp which matches the radtest prompt.
global radtest_prompt
if ![info exists radtest_prompt] then {
    set radtest_prompt "radtest> "
}

### Only procedures should come after this point.

proc default_radiusd_version {} {
    global RADIUSD
    global RADIUSFLAGS
    global RADIUSVERSION
    global RADIUSFLAGS
    global CAPABILITY

    if [info exists RADIUSVERSION] {
	return
    }
    
    set output [remote_exec host "$RADIUSD --version"]

    set tmp [split [lindex $output 1] '\n'];
    regsub ".*GNU Radius version (\[0-9.\]+).*" [lindex $tmp 0] "\\1" RADIUSVERSION
    set flags ""
    regexp "Compilation flags: (.*)\r?" [lindex $tmp 3] m RADIUSFLAGS
    set flg [split $RADIUSFLAGS]
    for {set i 0} {$i < [llength $flg]} {incr i} {
	set CAPABILITY([lindex $flg $i]) 1
    }
}

proc radiusd_version {} {
    global RADIUSD
    global RADIUSVERSION
    global RADIUSFLAGS
    
    default_radiusd_version
    if ![is_remote host] {
	clone_output "[which $RADIUSD] version $RADIUSVERSION \[$RADIUSFLAGS\]"
    } else {
	clone_output "$RADIUSD on remote host version $RADIUSVERSION \[$RADIUSFLAGS\]"
    }
}

proc default_radiusd_start {args} {
    global base_dir
    global srcdir
    global verbose
    global RADIUSD
    global RADIUSFLAGS
    global RADTEST
    global radtest_prompt
    global CAPABILITY

    default_radiusd_version

    set sw $args
    append sw " "
    
    if [info exists CAPABILITY(USE_SERVER_GUILE)] {
	append sw "--guile"
    } 

    if [info exists host_board] {
	if [board_info $host_board exists top_srcdir] {
	    append sw " --srcdir [board_info $host_board top_srcdir]"
	}
	if [board_info $host_board exists top_builddir] {
	    append sw " --builddir [board_info $host_board top_builddir]"
	}
    }

    append sw " --radiusd $RADIUSD --radtest $RADTEST --driver dejagnu"
    
    if {![is_remote host]} {
        set radiusd_cmd "$base_dir/test.sh $sw"
    } else {
        regexp "(.*)/radiusd$"  $RADIUSD m path
        set radiusd_cmd "$path/../test.sh $sw"
    }

    verbose "Spawning $radiusd_cmd"

    set res [remote_spawn host $radiusd_cmd]
    if { $res < 0 || $res == "" } {
	perror "Spawning $RADIUSD failed."
	return 1;
    }

    radius_expect 360 {
	-re "\[\r\n\]?${radtest_prompt}$" {
	    verbose "RADIUS initialized."
	}
	eof {
	    perror "(eof) RADIUS not initialized."
	    remote_close host;
	    return -1;
	}
	timeout	{
	    perror "(timeout) RADIUS not initialized after 10 seconds."
	    remote_close host;
	    return -1
	}
	default {
	    perror "GOT $expect_out(buffer)"
	}
    }
    return 0
}

proc default_radiusd_stop {} {
    verbose "Stopping radiusd"
    radius_exit 
}

proc radiusd_start {} {
    return [default_radiusd_start];
}
    
proc radiusd_stop {} {
    return [default_radiusd_stop];
}

##

proc radius_send { string } {
    global suppress_flag;
    if {[info exists suppress_flag] && $suppress_flag} {
	return "suppressed";
    }
    return [remote_send host "$string"]
}

proc radius_exit {} {
    set res [radius_send "exit\n"]
    sleep 5
    return res
}

proc radius_expect { args } {

    if { [lindex $args 0] == "-notransfer" } {
	set notransfer -notransfer;
	set args [lrange $args 1 end];
    } else {
	set notransfer "";
    }

    if { [llength $args] == 2  && [lindex $args 0] != "-re" } {
	set gtimeout [lindex $args 0];
	set expcode [list [lindex $args 1]];
    } else {
	upvar timeout timeout;

	set expcode $args;
	if [target_info exists radiusd,timeout] {
	    if [info exists timeout] {
		if { $timeout < [target_info radiusd,timeout] } {
		    set gtimeout [target_info radiusd,timeout];
		} else {
		    set gtimeout $timeout;
		}
	    } else {
		set gtimeout [target_info radiusd,timeout];
	    }
	}

	if ![info exists gtimeout] {
	    global timeout;
	    if [info exists timeout] {
		set gtimeout $timeout;
	    } else {
		# Eeeeew.
		set gtimeout 60;
	    }
	}
    }
    global suppress_flag;
    global remote_suppress_flag;
    global verbose
    if [info exists remote_suppress_flag] {
	set old_val $remote_suppress_flag;
    }
    if [info exists suppress_flag] {
	if { $suppress_flag } {
	    set remote_suppress_flag 1;
	}
    }

    verbose "RUNNING remote_expect host $gtimeout $notransfer" 2
    set code [catch \
	{uplevel remote_expect host "$gtimeout $notransfer" $expcode} string];
    if [info exists old_val] {
	set remote_suppress_flag $old_val;
    } else {
	if [info exists remote_suppress_flag] {
	    unset remote_suppress_flag;
	}
    }

    if {$code == 1} {
        global errorInfo errorCode;

	return -code error -errorinfo $errorInfo -errorcode $errorCode $string
    } elseif {$code == 2} {
	return -code return $string
    } elseif {$code == 3} {
	return
    } elseif {$code > 4} {
	return -code $code $string
    }
}

# radius_test COMMAND EXPECT PATTERN
# COMMAND   - Command to send to radtest
# EXPECT    - Expect or print command
# PATTERN   - Sequence to expect in return
# Return value:
#        -3 - eof
#        -2 - timeout
#        -1 - generic failure
#         1 - test fails
#         0 - test succeeds
proc default_radius_test { args } {
    global verbose
    global radtest_prompt
    global suppress_flag;
    upvar timeout timeout

    set command [lindex $args 0]
    set expect [lindex $args 1]
    set pattern [lindex $args 2]
    
    if { [info exists suppress_flag] && $suppress_flag } {
	set do_suppress 1
    } else {
	set do_suppress 0
    }

    if $verbose>2 then {
	send_user "Command: \"$command\"\n"
	send_user "Expect : \"$expect\"\n"
	send_user "Pattern: \"$pattern\"\n"
    }
    
    set result -1
    if { [radius_send "${command}\n"] != "" } {
	if { ! $do_suppress } {
	    perror "Couldn't send \"$command\".";
	}
	return $result;
    }

    if [info exists timeout] {
	set tmt $timeout;
    } else {
	global timeout;
	if [info exists timeout] {
	    set tmt $timeout;
	} else {
	    set tmt 60;
	}
    }

    radius_expect $tmt {
	-re "$radtest_prompt" {
	    verbose "GOT PROMPT" 2;
	}
	timeout	{
	    return $result 
	}
	eof {
	    return $result 
	}   
    }

    if { [radius_send "${expect}\n"] != "" } {
	if { [info exists suppress_flag] && ! $suppress_flag } {
	    perror "Couldn't send expect command.";
	}
	return $result;
    }

    radius_expect $tmt {
	-ex "${pattern}" {
	    set result 0
	}
	default {
	    set result 1
	}
	timeout	{
	    set result -2
	}
	eof {
	    set result -3
	}   
    }
    return $result
}

# simple_radius_test [-prereq CAPA][-message MESSAGE][-default (FAIL|XFAIL)]
#                    COMMAND EXPECT [PATTERN]
# COMMAND   - Command to send to radtest.
# EXPECT    - Expect command.
# PATTERN   - Sequence to expect in return. If ommitted, defaults to "PASS".
# MESSAGE   - [optional] message to output
proc simple_radius_test { args } {
    global verbose
    global radtest_prompt
    global suppress_flag;
    upvar timeout timeout

    set default ""
    set message ""
    set capa [list]
    for {set i 0} {$i < [llength $args]} {incr i} {
	set a [lindex $args $i]
	if {"$a" == "-default"} {
	    incr i
	    set default [lindex $args $i]
	} elseif {"$a" == "-message"} {
	    incr i
	    set message [lindex $args $i]
	} elseif {"$a" == "-prereq"} {
	    incr i
	    lappend capa [lindex $args $i]
	} else {
	    set args [lrange $args $i [llength $args]]
	    break
	}
    }

    if {"$message" == ""}  {
	set message [lindex $args 0]
    }

    if $verbose>2 then {
	send_user "Message is \"$message\"\n"
    }
    set command [lindex $args 0]
    set expect [lindex $args 1]

    # Check the prerequisite capabilities
    default_radiusd_version
    for {set i 0} {$i < [llength $capa]} {incr i} {
	if {! [info exists CAPABILITY([lindex $capa $i])]} {
	    verbose "Required capability [lindex $capa $i] not present" 1
	    unsupported $message
	    return 0
	}
    }    

    if {[llength $args] > 2} {
	set result [default_radius_test $command $expect [lindex $args 2]]
    } else {
	set result [default_radius_test $command $expect "PASS"]
    }
    if {$result == 0} {
	pass "$message"
    } elseif {$result == 1} {
	if { "$default" == "" || "$default" != "FAIL" } {
	    fail "$message"
	} else {
	    xfail "$message"
	    set result 0
	}
    } elseif {$result == -2} {
	fail "$message (timeout)"
    } elseif {$result == -3} {
	fail "$message (eof)"
    } else {
	fail "$message"
    }
    return $result
}

if [info exists env(REPTCOUNT)] {
	set reptcount $env(REPTCOUNT)
} else {
	set reptcount 1
}

proc radius_test {args} {
    global reptcount
    for {set i 0} {$i < $reptcount} {incr i} {
	eval simple_radius_test $args
    }
}
	
