@c This is part of the Radius manual.
@c Copyright (C) 2004 Free Software Foundation, Inc.
@c Written by Sergey Poznyakoff
@c See file radius.texi for copying conditions.
@comment *******************************************************************
@node radtest
@section radtest
@pindex radtest
@UNREVISED{}

@command{Radtest} is a radius client shell, providing a simple and
convenient language for sending requests to @RADIUS{} servers and
analyzing their reply packets.

@menu
* Literal Values::
* Reserved Keywords::
* Variables in radtest::
* Positional Parameters::
* Expressions in radtest::
* Function Definitions::
* Interacting with Radius Servers::
* Conditional Statements::
* Loops::
* Built-in Primitives::
@end menu

@node Literal Values
@subsection Literal Values

There are four basic data types in @command{radtest} language: @code{integer},
@code{ipaddr}, @code{string} and @code{avlist}.

@dfn{Integer} means a signed integer value in the range
-2147483648..2147483647.

@dfn{Ipaddr} is an unsigned integer value suitable for representing
@sc{ip}v4 addresses. These can be input either as decimal numbers or
as @IP{}s in usual ``dotted-quad'' notation.

@dfn{String} is an arbitrary string of characters. Any input token
consisting of letters of Latin alphabet, decimal digits, underscores
dashes and dots and starting with a Latin alphabet letter or
underscores is considered a string. To input strings containing other
letters, surround them by double quotes. The following are valid strings:

@smallexample
@group
A-string
"String, containing white space"
@end group
@end smallexample

The double quote character @samp{"} must be preceeded by a backslash
@samp{\} if it is part of a string:

@smallexample
"Always quote \" character"
@end smallexample

Generally speaking, @samp{\} is an @dfn{escape character}, that
alters the meaning of the immediately following character. If it is
located at the end of the line, it allows to input newline
character to strings:

@smallexample
@group
"This string contains a \
newline character."
@end group
@end smallexample

Other special escape sequences are:

@table @asis
@item \a
Audible bell character (ASCII 7)
@item \b
Backspace (ASCII 8)
@item \e
Escape character (ASCII 27)
@item \f
Form feed (ASCII 12)
@item \n
Newline (ASCII 10)
@item \r
Carriage return (ASCII 13)
@item \t
Horizontal tab (ASCII 9)
@item \\
Backslash
@item \ooo
(@samp{o} represents an octal digit)
A character whose ASCII value is represented by the octal number @samp{ooo}.
@item \xHH
@itemx \XHH
(@samp{H} represents a hex digit)
A character whose ASCII value is represented by the hex number @samp{HH}.
@end table

If the character following the backslash is not one of those
specified, the backslash is ignored.

@anchor{STRNUM}An important variant of @code{string} is a @dfn{numeric string},
or @dfn{STRNUM} for short. A numeric string is a string that
can be converted to a number, for example @code{"+2"}. This concept
is used for type conversion between @code{integer} and @code{string}
values.

@dfn{Avlist} are whitespace or comma-separated lists of
@RADIUS{} attribute-value pairs. A syntax for @AVP{} is

@example
@var{name} @var{op} @var{value}
@end example

@noindent
where @var{name} is attribute name, @var{op} is a comparison
operator (@samp{=}, @samp{!=}, @samp{<}, @samp{<=}, @samp{>},
@samp{>=}), and @var{value} is any valid @command{radtest} data
or expression.
An @AVP{} list must be enclosed in parentheses. This is an
example of an @AVP{} list consisting of two pairs:

@smallexample
@group
( User-Name = "test" NAS-IP-Address = 10.10.10.1 )
@end group
@end smallexample

@noindent
An empty pair list is represented by a pair of parentheses: @code{()}.

@node Reserved Keywords
@subsection Reserved Keywords

The following keywords are reserved in @command{radtest}:

@smallexample
@group
acct, and, auth, begin, break, case, continue, 
do, else, end, exit, expect, getopt, if,       
in, input, not, or, print, return, send,     
set, shift, while    
@end group
@end smallexample

The reserved keywords may be used as variable names, provided that
the following requrements are met:

@itemize @bullet
@item In assignment, these names are quoted using single quotes.

@smallexample
'case' = 1
@end smallexample

@item When dereferencing, the use of curly braces is obligatory:

@smallexample
$@{case@} + 2
@end smallexample
@end itemize

@node Variables in radtest
@subsection Variables

Variables are means of storing data values at one point of your
program for using them in another parts of it. Variables can be
assigned either in the program itself, or from the @command{radtest}
command line.

@menu
* Using Variables::
* Variable Assignments::
* Dereferencing Variables::
* Accessing Elements of A/V Pair Lists::
* Assignment Options::
* Built-in Variables::
@end menu

@node Using Variables
@subsubsection Using Variables

The name of a variable must be a sequence of letters, digits,
underscores and dashes, but it may not begin with a digit or dash. Notice,
that in contrast to the majority of programming languages, use of
dashes (minus signs) is allowed in user names. This is because
traditionally @RADIUS{} attribute names contain dashes, so
extending this practice to variable names makes @code{radtest}
programs more consistent. On the other hand, this means that you
should be careful when using minus sign as a subtraction
operator (@pxref{dash-ambiguity}). Case is significant in variable names:
@code{a} and @code{A} are different variables. 

A name of a variable may coincide with one of @code{radtest} reserved
keywords. @xref{Reserved Keywords}, for description on how to use such
variables.

A few variables have special built-in meanings (@pxref{Built-in Variables}). Such
variables can be assigned and accessed just as any other ones. All
built-in variables names are entirely upper-case.

Variables are never declared, they spring into existence when
an assignment is made to them. The type of a variable is determined
by the type of the value assigned to it. 

@node Variable Assignments
@subsubsection Variable Assignments

An @dfn{assignment} stores a new value into a variable. It's syntax
is quite straightforward:

@smallexample
@var{variable} = @var{expression}
@end smallexample

@noindent
As a result of the assignment, the @var{expression} is evaluated and
its value is assigned to @var{variable}. If @var{variable} did not
exist before the assignment, it is created. Otherwise, whatever old
value it had before the assignment is forgotten.

It is important to notice that variables do @emph{not} have
permanent types. The type of a variable is the type of whatever
value it currently holds. For example:

@smallexample
@group
foo = 1
print $foo @result{} 1
foo = "bar"
print $foo @result{} bar
foo = ( User-Name = "antonius" NAS-IP-Address = 127.0.0.1 )
print $foo @result{} ( User-Name = "antonius" NAS-IP-Address = 127.0.0.1 )
@end group
@end smallexample

Another important point is that in @command{radtest}, assignment is
not an expression, as it is in many other programming languages. So
@code{C} programmers should resist temptation to use assignments in
expressions. The following is @emph{not} correct:

@smallexample
x = y = 1
@end smallexample

Finally, if the variable name coincides with one of @command{radtest}
keywords, it must be enclosed in single quotes:

@smallexample
'case' = 1
@end smallexample

@node Dereferencing Variables
@subsubsection Dereferencing Variables

@dfn{Dereferencing} a variable means accessing its value. The
simplest form of dereferencing is by prepending a dollar sign
to the variable name:

@smallexample
@group
foo = 1
print foo @result{} foo
print $foo @result{} 1
@end group
@end smallexample

@noindent
Notice, that in the example above, the first @code{print} statement
understands @code{foo} as a literal string, whereas the second one
prints the value of the variable.

Dereferencing an undefined variable produces error message:

@smallexample
print $x @error{} variable `x' used before definition
@end smallexample

Optionally, the variable name may be surrounded by curly braces.
Both @code{$foo} and @code{$@{foo@}} are equivalent. The use of
the latter form is obligatory only when the variable name coincides
with one of the reserved keywords (@pxref{Reserved Keywords}).
@anchor{dash-ambiguity}It also can be used to resolve ambiguity between using dash as
a part of user name and as a subtraction operator:

@smallexample
@group
long-name = 2
$long-name @result{} 2
$long-name-1 @error{} variable `long-name-1' used before definition
$@{long-name@}-1 @result{} 1
$long-name - 1 @result{} 1
@end group
@end smallexample

We recommend to always surround @samp{-} with whitespace when it is
used as arithmetic operator.

The @code{$@{@}} notation also permits some operations similar to
shell variable substitution.

@table @asis
@item $@{variable:-text@}
Use default values. If @var{variable} is unset, return @var{text},
otherwise return the value of the @var{variable}.

@smallexample
@group
$x @error{} variable `x' used before definition
$@{x:-1@} @result{} 1
x = 2
$@{x:-1@} @result{} 2
@end group
@end smallexample

@item $@{variable:=text@}
Assign default values. If @var{variable} is unset, @var{text} is
assigned to it. The expression always returns the value of the
variable.

@smallexample
@group
$x @error{} variable `x' used before definition
$@{x:=1@} @result{} 1
$x @result{} 1
@end group
@end smallexample

@item $@{variable:?text@}
Display error if unset. If @var{variable} is unset, @var{text} is
written to the standard error (if @var{text} is empty, the default
diagnostic message is used) and further execution of the program is
aborted. Otherwise, the value of @var{variable}
is returned. 

@smallexample
@group
$x @error{} variable `x' used before definition
$@{x:?@} @error{} x: variable unset
$@{x:?foobar@} @error{} foobar
@end group
@end smallexample

@item $@{variable::text@}
Prompt for the value if unset. If @var{variable} is unset,
@command{radtest} prints @var{text} (or a default message, if it
is empty), reads the standard input up to the newline character
and returns the value read. Otherwise, the value of the variable
is returned. This notation provides a convenient way for asking
user to supply default values.

@smallexample
@group
$@{x::@} @print{} (<teletype>:1)x?
$@{x::Enter value of x: @} @print{} Enter value of x: 
@end group
@end smallexample

@item $@{variable:&text@}
Prompt for the value with echo turned off if unset. This is similar
to the @code{$@{variable::text@}}, with the exception that the input
value will not be echoed on the screen. This notation provides a
convenient way for asking user to supply default values for variables
(such as passwords, shared secrets, etc.) while preventing them from
being compromised. 

@end table

@node Accessing Elements of A/V Pair Lists
@subsubsection Accessing Elements of A/V Pair Lists

Elements of an @code{avlist} are accessed as if it were an array,
i.e.:

@smallexample
$@var{variable} [ @var{attribute-name} ]
@end smallexample

If the attribute @var{attribute-name} is of @code{string} data type
and @var{variable} may contain more than one pair with this attribute,
adding an asterisk after @var{attribute-name} returns concatenated
values of all such pairs:

@smallexample
$@var{variable} [ @var{attribute-name} * ]
@end smallexample

Examples:

@smallexample
@group
x = (NAS-Port-Id = 127.0.0.1 \
     Reply-Message = "a long"
     Reply-Message = " string"

$x[NAS-Port-Id] @result{} 127.0.0.1
$x[Reply-Message] @result{} "a long"
$x[Reply-Message*] @result{} "a long string"
@end group
@end smallexample

@FIXME{How to get @var{n}th instance of an attribute? What gets
returned if there is no such attribute in the list?}

@node Assignment Options
@subsubsection Assignment Options

You can set any @command{radtest} variable from the command line.
There are two ways of doing so.

First, you can use @dfn{variable assignment option} @option{--assign}
(or @option{-a}). Its syntax is:

@smallexample
@group
--assign @var{variable}=@var{text}
-a @var{variable}=@var{text}
@end group
@end smallexample

@noindent
For example:

@smallexample
radtest -a foobar=5
@end smallexample

Another way is useful when you load a @code{radtest} program by
@option{--file} or @option{-f}. This second way consists in including
a variable assignment in the form

@smallexample
@var{variable}=@var{text}
@end smallexample

@noindent
in the command line after the script name. For example:

@smallexample
radtest -f myprog.rad foo=5 addr=127.0.0.1
@end smallexample

@noindent
This method is especially useful for executable scripts that are
run using @code{#!} shell magic. Consider a simple script:

@smallexample
@group
#! /usr/local/bin/radtest -f
print $addr
@end group
@end smallexample

@noindent
The value of @var{addr} can be given to the script from the command
line as in the example below:

@smallexample
myprog.rad addr=127.0.0.1
@end smallexample

@node Built-in Variables
@subsubsection Built-in Variables

The following variables are predefined:

@table @var
@item _

Contains the result of last evaluated expression.

@item REPLY_CODE

Contains the last reply code received from the @RADIUS{} server
(@code{integer}).

@item REPLY

Contains the @AVP{}s lastly received from the @RADIUS{} server
(@code{avlist}).

@item SOURCEIP

Contains the source @IP{} of the @RADIUS{} client (@code{ipaddr}).
By default, it equals the @IP{} set via @code{source_ip} statement
in your @file{client.conf} file (@pxref{client.conf}).

@end table

@node Positional Parameters
@subsection Positional Parameters

Normally @command{radtest} stops parsing its command line
when it encounters either first non-optional argument
(i.e. the one not starting with dash), or an argument consisting
of two dashes. The rest of the command line starting from the
first non-optional argument forms @dfn{positional parameters}.
These parameters are said to form the @dfn{top-level environment}.

Similarly, when invoking a user-defined function (@pxref{Function
Definitions}), arguments passed to it are said to form the
@dfn{current environment} of the function. These arguments are
positional parameters for this function.

Positional parameters are assigned numbers starting from 1. To access
(@dfn{dereference}) a positional parameter, the syntax @code{$@var{n}}
is used, where @var{n} is the number of the parameter. Alternative
forms, such as @code{$@{@var{n}@}} or @code{$@{@var{n}:-text@}},
can also be used. These work exactly as described in
@ref{Dereferencing Variables}).

The number of positional parameters can be accessed using a special
notation @code{$#}.

Several things need to be mentioned:

@itemize @bullet
@item All top-level positional parameters have @code{string} data
type, whereas the types of positional parameters in a function
current environment are determined before inoking the function.

@item Special notion @code{$0} returns the name of the function
being evaluated. When used in the top-level environment, it returns
the name of @command{radtest} program as given by @option{--file}
(@option{-f}) option.

@item Dereferencing non-existing parameter returns empty string. This
differs from dereferencing non-existing variable, which results in
error.

@item @code{AWK} programmers should note that assignments
(@pxref{Assignment Options}) are not included in the top level
environment (see example below).
@end itemize

For example, suppose you run: 

@smallexample
radtest -f script.rad name foo=bar 5
@end smallexample

Then, the top-level environment of program @file{script.rad} consists
of the following variables:

@smallexample
@group
$0 @result{} script.rad
$1 @result{} name
$2 @result{} 5
@end group
@end smallexample

@node Expressions in radtest
@subsection Expressions

An @dfn{expression} evaluates to a value, which can be printed,
assigned to a variable, used in a conditional statement or passed
to a function. As in other languages, expressions in @command{radtest}
include literals, variable and positional parameter dereferences,
function calls and combinations of these with various operators.

@menu
* Arithmetic Ops::
* String Ops::
* A/V List Ops::
* Comparison Ops::
* Boolean Ops::
* Conversion Between Data Types::
* Function Calls::
* Precedence::
@end menu

@node Arithmetic Ops
@subsubsection Arithmetic Operations

@command{Radtest} provides the common arithmetic operators, which
follow normal precedence rules (@pxref{Precedence}), and work as
you would expect them to. The only notable exception is subtraction
operator (minus) which can be used as part of a variable or attribute
name, and therefore expressions like @code{$x-3} are ambiguous. This
expression can be thought of either as a dereference of the variable
@code{x-3} (@pxref{Dereferencing Variables}), or as subtraction of the value
@code{3} from the value of the variable @code{x}. @command{Radtest}
always resolves this ambiguityin the favor of variable dereference.
Therefore we advise you to always surround minus sign by whitespace,
if it is used as a subtraction operator. So, instead of @code{$x-3},
write @code{$x - 3}. For other methods of solving this ambiguity,
@xref{dash-ambiguity}.

This table lists the arithmetic operators in order from highest
precedence to lowest:

@table @code
@item - @var{x}
Negation.

@item + @var{x}
Unary plus. This is equivalent to @code{@var{x}}. @FIXME{Should this
imply converting @var{x} to integer?}

@item @var{x} * @var{y}
Multiplication.

@item @var{x} / @var{y}
Division.

@item @var{x} % @var{y}
Remainder.

@item @var{x} + @var{y}
Addition.

@item @var{x} - @var{y}
Subtraction.

@end table

Unary plus and minus have the same precedence, the multiplication,
division and remainder all have the same precedence, and addition and
subtraction have the same precedence.

If @var{x} and @var{y} are of different data types, their
values are first coerced to a common data type, selected
using a set of rules (@pxref{Conversion Between Data Types}).

@node String Ops
@subsubsection String Operations

There is only one string operation: concatenation. It is represented
by plus sign, e.g.:

@smallexample
"string" + "ent" @result{} "stringent"
@end smallexample

@node A/V List Ops
@subsubsection Operations on A/V Lists
@UNREVISED{}

The following operations are defined on A/V lists:

@table @code
@item @var{x} + @var{y}
@dfn{Addition}. The @AVP{}s from @var{y} are added to @var{x}, honoring
the respective pairs additivity (@pxref{Attributes,,additivity}).
For example:

@smallexample
( User-Name = "foo" ) + ( Password = "bar" )
@result{} ( User-Name = "foo" Password = "bar" )

( User-Name = "foo" Service-Type = Login-User ) + \
 ( Service-Type = Framed-User Password = "bar" )
@result{} ( User-Name = "foo" \
          Service-Type = Framed-User \
          Password = "bar" )
@end smallexample

@item @var{x} - @var{y}
@dfn{Subtraction}. The result of this operation is an A/V list
consisting of pairs from @var{x}, which are not found in @var{y}.

@smallexample
( User-Name = "foo" Service-Type = Login-User ) - \
( Service-Type = Framed-User )
@result{} ( User-Name = "foo" )
@end smallexample

Notice, that only attribute name matters, its value is
ignored@FIXME{Is this correct? Is there a better way to put it?
should we provide an operation that whould compare both attribute
number and its value?}

@item @var{x} % @var{y}
@dfn{Intersection}. The result of this operation is an @AVP{} list
consisting of pairs from @var{x} which are also present in @var{y}.

@smallexample
( User-Name = "foo" Service-Type = Login-User ) - \
( Service-Type = Framed-User )
@result{} ( Service-Type = Login-User )
@end smallexample

@FIXME{Same as above.}
@end table

@node Comparison Ops
@subsubsection Comparison Operations

@dfn{Comparison expressions} compare operands for relationships
such as equality. They return boolean values, i.e. @code{true}
or @code{false}. The comparison operations are nonassociative,
i.e. they cannot be used together as in:

@smallexample
# @emph{Wrong!}
1 < $x < 2
@end smallexample

Use boolean operations (@pxref{Boolean Ops}) to group comparisons together.

Comparison operations can only be used in conditional expressions.

This table lists all comparison operators in order from highest
precedence to lowest (notice, however, the comment after it):

@table @code
@item @var{x} = @var{y}
True if @var{x} is equal to @var{y}. @code{C} and @code{AWK}
programmers, please note @emph{single} equal sign!

@item @var{x} != @var{y}
True if @var{x} is not equal to @var{y}.

@item @var{x} < @var{y}
True if @var{x} is less than @var{y}.

@item @var{x} <= @var{y}
True if @var{x} is less than or equal to @var{y}.

@item @var{x} > @var{y}
True if @var{x} is greater than @var{y}.

@item @var{x} >= @var{y}
True if @var{x} is greater than or equal to @var{y}.
@end table

Operators @code{=} and @code{!=} have equal precedence. Operators
@code{<}, @code{<=}, @code{>}, @code{>=} have equal precedence. 

Most operators are defined for all @command{radtest} data types.
However, only @code{=} and @code{!=} are defined for @code{avlist}s.
Using any other comparison operator with @code{avlist}s produces
error.

If @var{x} and @var{y} are of different data types, their
values are first coerced to a common data type, selected
using a set of rules (@pxref{Conversion Between Data Types}).

@node Boolean Ops
@subsubsection Boolean Operations

A @dfn{boolean operation} is a combination of comparison expressions.
Boolean operations can only be used in conditional expressions.

This table lists all comparison operators in order from highest
precedence to lowest.

@table @code
@item not @var{x}
@itemx ! @var{x}
True if @var{x} is false.

@item @var{x} and @var{y}
True if both @var{x} and @var{y} are true. The subexpression @var{y}
is evaluated only if @var{x} is true.

@item @var{x} or @var{y}
True if at least one of @var{x} or @var{y} is true. The subexpression @var{y}
is evaluated only if @var{x} is false.
@end table

@node Conversion Between Data Types
@subsubsection Conversion Between Data Types
@UNREVISED{}

The unary negation operand is always converted to @code{integer} type:

@smallexample
@group
-(1 + 1)  @result{} -2
-(127.0.0.1 + 2) @result{} -2130706435
- ("1" + "1") @result{} -11
- "text" @error{} cannot convert string to integer
@end group
@end smallexample

@noindent
The unary @code{not} operand is converted using the following rules:

@enumerate 1
@item If the operand is @code{integer}, no conversion is performed.
@item If the operand is @code{STRNUM} (@pxref{STRNUM}) or
@code{ipaddr}, it is converted to integer.
@item If the operand is @code{string} (but is not @code{STRNUM}), the
result of @code{not} is @code{true} only if the operand is an empty
string.
@item If the operand is @code{avl}, the result of @code{not} is
@code{true} if the list is empty.
@end enumerate

Examples:

@smallexample
@group
not 0 @result{} 1
not 10 @result{} 0
not "23" @result{} 0
not "0" @result{} 1
not "text" @result{} 0
not "" @result{} 1
not 127.0.0.1 @result{} 0
not 0.0.0.0 @result{} 1
@end group
@end smallexample

When operands of two different data types are used in a binary
operation, one of the operands is converted (@dfn{cast}) to another
operand's type according to the following rules:

@enumerate 1
@item If one of the operands is literal, @command{radtest} attemtps
to convert another operand to the literal data type. If this attempt
fails, it goes on to rule 2.
@item If one of operands is @code{STRNUM} (@pxref{STRNUM}) and another is of numeric
data type (i.e. either @code{integer} or @code{ipaddr}), the latter is converted
to string representation.
@item If one of the operands is @code{ipaddr} and another is
@code{integer}, the latter is converted to @code{ipaddr}.
@item Otherwise, if one of the operands is string, the second operand
is also converted to string.
@item Otherwise, the two operands are incompatible. @command{Radtest}
prints appropriate diagnostics and aborts execution of the current
statement.
@end enumerate

@node Function Calls
@subsubsection Function Calls

A @dfn{function} is a name for a particular sequence of statements. It
is defined using special definition syntax (@pxref{Function
Definitions}). Normally a function return some value. The way to
use this value in an expression is with a @dfn{function call}
expression, which consists of the function name followed by a
comma-separated list of @dfn{arguments} in
parentheses. The arguments are expressions which provide values for
the function call environment (@pxref{Positional Parameters}. When
there is more than one argument, they are separated by commas.
@FIXME{Actually, commas in the argument list are optional. At least,
now...} If there are no arguments, write just @samp{()} after the
function name. Here are some examples:

@smallexample
@group
foo()             no arguments
bar(1)            one argument
bar(1, "string")  two arguments
@end group
@end smallexample

@node Precedence
@subsubsection Operator Precedence (How Operators Nest)
@UNREVISED{}

@node Function Definitions
@subsection Function Definitions

A @dfn{function} is a name for a particular sequence of statements.
The syntax for the function definition is:

@smallexample
@var{name}
begin
  @dots{}
end
@end smallexample

@noindent
where @var{name} is function name and @samp{@dots{}} represent a
non-empty list of valid @command{radtest} statements.

Notice that newline characters are obligatory after @var{name},
@code{begin} and before the final @code{end} keyword.

If the function accepts arguments, these can be referenced in the
function body using @code{$@var{n}} notation (@pxref{Positional
Parameters}). To return the value from the function @code{return}
statement is used.

For example, here is a function that computes sum of the squares
of its two arguments:

@smallexample
@group
hypo
begin
        return $1*$1 + $2*$2
end
@end group
@end smallexample   

@node Interacting with Radius Servers
@subsection Interacting with Radius Servers

@command{Radtest} provides two commands for interaction with remote
@RADIUS{} servers.

Command @code{send} sends request to the server specified in
@file{raddb/client.conf}. Its syntax is:

@smallexample
send [@var{flags}] @var{port-type} @var{code} [@var{expr-or-pair-list}]
@end smallexample

Optional @var{flags} can be used for fine-tuning the internals of
@code{send}. You will seldom need to use these, unless you are
developing GNU Radius. @FIXME-xref{send-flags}, for the detailed
description of these.

The first obligatory argument, @var{port-type}, specifies which
@RADIUS{} port to send the request to. Specifying @samp{auth} will
send the request to the authentication port (@pxref{client.conf,auth-port});
specifying @samp{acct} will send it to the accounting port
(@pxref{client.conf,acct-port}).

Argument @var{code} gives the request code. It is either a number or
a symbolic request code name (@FIXME-xref{}).

The last argument, @var{expr-or-pair-list} is either a
@command{radtest} expression evaluating to @code{avlist} or a list
of @AVP{}s. These pairs will be included in the request.

Here are several examples:

@smallexample
# Send a @code{Status-Server} request without attributes.
send auth Status-Server

# Send an @code{Access-Request} with two attributes
send auth Access-Request User-Name = "foo" User-Password = "bar"

# Send an Accounting-Request, taking attributes from the variable
# @var{attr}
send acct Accounting-Request $attr
@end smallexample

Command @code{send} stores the reply code into the variable
@code{REPLY_CODE} and reply pairs into the variable @code{REPLY}
(@pxref{Built-in Variables}).
@FIXME{How to know if @code{send} has failed?}

Another primitive is @code{expect}. @code{Expect} takes at most two
arguments: a request code (either numeric or symbolic) and optional
list of @AVP{}s (similar to @code{send} @var{expr-or-pair-list}
argument). @code{Expect} check if these match current
@code{REPLY_CODE} and @code{REPLY} values and if so, prints
the string @samp{PASS}. Otherwise, it prints @samp{FAIL}. This
command is designed primarily for use in GNU Radius testsuite.

@code{Expect} is usually used right after @code{send}, as shown
in the example below:

@smallexample
@group
send auth Access-Request User-Name = "foo" User-Password = "bar"
expect Access-Accept Reply-Message = "Access allowed"
@end group
@end smallexample

@node Conditional Statements
@subsection Conditional Statements
@UNREVISED{}

@command{Radtest} provides two kinds of conditional statements:
@code{if} and @code{case}.

@subheading If statement

An @code{if} statement in its simplest form is:

@smallexample
if @var{cond} @var{stmt}
@end smallexample

@noindent
where @var{cond} is a conditional expression and @var{stmt} is a
valid @command{radtest} statement. Optional newline may be inserted
between @var{cond} @var{stmt}.

In this form, @code{if} evaluates the condition and if it yields true,
executes the statement. For example:

@smallexample
@group
if $REPLY[NAS-IP-Address] = 127.0.0.1
   print "Request from localhost"
@end group
@end smallexample

More complex form of this statement allows to select between the two
statements:

@smallexample
@group
if @var{cond} @var{stmt-1} else @var{stmt-2} 
@end group
@end smallexample

@noindent
Here, @var{stmt-1} will be executed if @var{cond} evaluates to true,
and @var{stmt-2} will be executed if @var{cond} evaluates to false.

Notice, that an optional newline is allowed between @var{cond} and
@var{stmt-1} and right after @code{else} keyword. However, a newline
before @code{else} constitutes an error.

If several statements should be executed in a branch of the @code{if}
statement, use compound statement as in the example below:

@smallexample
@group
if $REPLY_CODE != Accounting-Response
begin
  print "Accounting failed.\n"
  exit 1	
end else
  print "Accounting succeeded.\n"
@end group
@end smallexample

@code{If} statements can be nested to any depth.

@subheading Case statement

@code{Case} statement allows select a statement based on whether
a @code{string} expression matches given regular expression. The
syntax of @code{case} statement is:

@smallexample
@group
case @var{expr} in
@var{expr-1} ) @var{stmt-1}
@var{expr-2} ) @var{stmt-2}
@dots{}
@var{expr-n} ) @var{stmt-n}
end
@end group
@end smallexample

@noindent
where @var{expr} is a control expression, @var{expr-1}, @var{expr-2}
etc. are expressions evaluating to @emph{extended} POSIX regular
expressions (for the detailed description of these
@pxref{Top,,Regular Expression Library,regex,Regular Expression
Library}).

@code{Case} statement first evaluates @var{expr} and converts it to
@code{string} data type. Then it evaluates each @var{expr-n} in turn
and tests if the resulting regular expression matches @var{expr}. If
so, the statement @var{stmt-n} is executed and the execution of
@code{case} statement finishes.

The following example illustrates the concept:

@smallexample
@group
case $COMMAND in
"auth.*")	authenticate($LIST, no)
"acct")         authenticate($LIST, yes)
".*")		begin
		  print "Unknown command."
		  exit 1
	        end
end
@end group
@end smallexample

@code{Bourne shell} programmers should notice that:

@itemize @bullet
@item @code{Case} statement ends with @code{end}, not @code{esac}.
@item There is no need to put @code{;;} at the end of each branch,
@item Boolean operations are not allowed in @var{expr-n}.
@end itemize

@node Loops
@subsection Loops
@UNREVISED

Two looping constructs are provided: @code{while} and
@code{do...while}.

@subsection While loop

The syntax of a while loop is:

@smallexample
@group
while @var{cond}
  @var{stmt}
@end group
@end smallexample 

Newline after @var{cond} is obligatory.

@subheading Do...while loop

@smallexample
@group
do
  @var{stmt}
while @var{cond}
@end group
@end smallexample  

As usual @code{do...while} loop differs from its @code{while}
counterpart in that its @var{stmt} is executed at least once.

The looping constructs can be nested to any depth.

Two special statements are provided for branching within loop
constructs. These are @code{break} and @code{continue}.

@code{Break} statement stops the execution of the current
loop statement and passes control to the statement immediately
following it

@smallexample
@group
while $x < 10
begin
  if $x < $y
     break
  @dots{}
  x = $x + 1
end
print "OK\n"
@end group
@end smallexample

@noindent
In the example above, execution of @code{break} statement passes
control to @code{print} statement.

@code{Break} may also take an argument: a literal number representing
the number of nested loop statements to break from. For example, the
@code{break} statement in the sample code below will exit from the
outermost @code{while}:

@smallexample
@group
while $y < 10
begin
  while $x < 10
  begin
    if $x < $y
       break 2
    @dots{}
    x = $x + 1 
  end
  @dots{}
  y = $y + 1 
end  
print "OK\n"
@end group
@end smallexample

@code{Continue} statement passes control to the condition of the
current looping construct. When used with a numeric argument, the
latter specifies the number of the nesting looping construct to
pass control to (as with @code{break}, the innermost loop is
considered to have number 1, so @code{continue} is equivalent
to @code{continue 1}).

@node Built-in Primitives
@subsection Built-in Primitives
@UNREVISED{}

@deffn {Radtest built-in} getopt [@var{opt}] [@var{arg}] [@var{ind}]
@end deffn

@deffn {Radtest statement} input [@var{expr} @var{name}]
@end deffn

@deffn {Radtest statement} set @var{options}
@end deffn

@deffn {Radtest statement} shift [@var{expr}]
@end deffn

@deffn {Radtest statement} return [@var{expr}]
@end deffn

@deffn {Radtest statement} break [@var{expr}]
@end deffn

@deffn {Radtest statement} continue [@var{expr}]
@end deffn

@deffn {Radtest statement} exit [@var{expr}]
@end deffn

@deffn {Radtest statement} print [@var{expr-list}]
@end deffn

@deffn {Radtest statement} send [@var{flags}] auth|acct @var{code} @var{expr-or-pair-list}
@var{flags} are a whitespace-separated list of variable
assignments. Following variables are understood:

@table @code
@item repeat
@item id
@item keepauth
@end table

@end deffn

@deffn {Radtest statement} expect @var{code} [@var{expr-or-pair-list}]
@end deffn

@c End of radtest.texi
